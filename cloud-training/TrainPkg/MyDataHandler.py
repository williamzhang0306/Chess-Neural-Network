### .csv files in the /Data are too large to load into memory
### .csv contain FEN string to represent the chess board (see https://en.wikipedia.org/wiki/Forsyth%E2%80%93Edwards_Notation)
### also contains centipawn evaluation generated by stockfish with depth = 22
### following the recomednations from this paper : https://www.ai.rug.nl/~mwiering/GROUP/ARTICLES/ICPRAM_CHESS_DNN_2018.pdf

import numpy as np
import pandas as pd
import keras
import math

def sigmoid(x):
  return 1 / (1 + math.exp(-x))

class DataGenerator(keras.utils.Sequence):

    def __init__(self, data_frame: pd.DataFrame, IDs: list, batch_size = 32, x_dim = (8,8,12), y_dim = (15,1), output_type = '15 classes', shuffle = True):
        
        self.dataframe = data_frame
        self.IDs = IDs
        self.batch_size = batch_size
        self.x_dim = x_dim
        self.y_dim = y_dim
        self.output_type = output_type
        self.shuffle = shuffle
        self.indexes = None
        self.on_epoch_end()

        # self.IDs correspond to the identifiers within the data frame to locate the FEN and Stockfish Evaluation
        # self.indexes are the indexes within the tensor object that is returned
        # there are as many indexes as IDs
        # e.g. Ids = ['a','d','b','z']
        # e.g. indexes = [ 0,  1,  2,  3]

    def on_epoch_end(self):
        'Update indexes at the end of an epoch'
        self.indexes = np.arange(len(self.IDs))
        if self.shuffle == True:
            np.random.shuffle(self.indexes)

    def fen_to_image(self, fen_string: str) -> np.array:
        '''Converts fen string to 8x8x13 (rows x cols x channels) image. 
        13 channels represent 12 pieces plue one channel for white or black is playing.
        In each pixel of the image, 1 represents a white piece is present, 
        -1 black piece present, 0 no piece present.'''
        # used for conversion
        piece_to_channel = {'P':0, 'N':1, 'B':2, 'R':3 , 'Q':4 , 'K':5,
                          'p':6, 'n':7, 'b':8, 'r':9, 'q':10, 'k':11}
        image = np.zeros(self.x_dim)

        # extract info from the fen string
        parts = fen_string.split(" ")
        fen_board = parts[0].split('/')
        active_color = parts[1]
        # populate the board image
        for i, row in enumerate(fen_board):
            j = 0
            for char in row:
                # if the character a piece, e.g. 'p' or 'K'
                if char in piece_to_channel:
                    # 1 if the piece is white, -1 if the piece is black
                    val = 1 if char.isupper() else -1
                    image[i, j, piece_to_channel[char]] = val
                    j += 1

                # otherwise the character is a number (number of empty squares in the row)
                else:
                    j += int(char)

        # add active side info
        #image[0,0,0] = 1 if active_color == 'w' else -1

        return image

    def classify_evaluation_15(self, evaluation: str) -> np.array:
        '''Classifies centipawn evaluation into 15 categories.
        Returns a one-hot encoded vector'''
        
        label = np.zeros(self.y_dim)

        ranges = [ 
            (-1000,-8.5), (-7.5,-6.5), (-6.5,-5.5), (-5.5,4.5), (-4.5,-3.5),(-2.5,-1.5),(-1.5,1.5), 
            (1.5,2.5), (2.5,3.5), (3.5,4.5), (4.5,5.5), (5.5,6.5), (6.5,7.5), (7.5,8.5), (8.5,1000)
        ]

        ### evaluation is inputed as a string, convert to a number
        # black has checkmate
        if '#' in evaluation and '-' in evaluation:
            evaluation = -100

        # white has checkmate
        elif '#' in evaluation and '+' in evaluation:
            evaluation = 100

        # regular centipawn evaluation
        else:
            try:
                evaluation = float(evaluation)/100
            except:
                # if there is bad label, just set it to zero
                # this happens rarely (I think) so I'll just ignore it for now :p
                evaluation = 0

        for index, domain in enumerate(ranges):

            if domain[0] < evaluation < domain[1]:
                label[index] = 1

        return label

    def classify_evaluation_3(self, evaluation: str):
        '''classifies evaluation into 3 categores. Draw, white winning, black winning'''

        label = np.zeros(self.y_dim)

        ranges = [ 
            (-1000,-1.5),(-1.5,1.5), (1.5,1000)
        ]

        ### evaluation is inputed as a string, convert to a number
        # black has checkmate
        if '#' in evaluation and '-' in evaluation:
            evaluation = -100

        # white has checkmate
        elif '#' in evaluation and '+' in evaluation:
            evaluation = 100

        # regular centipawn evaluation
        else:
            try:
                evaluation = float(evaluation)/100
            except:
                # if there is bad label, just set it to zero
                # this happens rarely (I think) so I'll just ignore it for now :p
                evaluation = 0

        for index, domain in enumerate(ranges):

            if domain[0] < evaluation < domain[1]:
                label[index] = 1

        return label

    def normalize_evaluation(self, evaluation: str):
        '''returns centipawn evaluation normalized between 0 and 1'''
        #label = np.zeros(self.y_dim)

        if '#' in evaluation and '-' in evaluation:
            evaluation = 0

        # white has checkmate
        elif '#' in evaluation and '+' in evaluation:
            evaluation = 1

        # regular centipawn evaluation
        else:
            try:
                evaluation = sigmoid(float(evaluation)/1000)
            except:
                # if there is bad label, just set it to zero point five
                # this happens rarely (I think) so I'll just ignore it for now :p
                evaluation = 0.5

        #label[0] = evaluation

        return evaluation

    def generate_data(self, batch_IDs, output_type):
        '''generaets the x and y data for all IDs within a mini batch.
        3 outputs, 'normalized', '3 classes' , '15 classes'
        Make sure y_dim matches output type '''
        
        output_func = {
            'normalized' : self.normalize_evaluation,
            '3 classes'  : self.classify_evaluation_3,
            '15 classes' : self.classify_evaluation_15
        }

        # initialize empty outputs
        x = np.empty((self.batch_size, *self.x_dim))
        y = np.empty((self.batch_size, *self.y_dim))

        # retrieve, format, and store data for every ID in the mini batch
        for i, ID in enumerate(batch_IDs):

            # get fen and evaluation
            fen = self.dataframe._get_value(ID, 'FEN')
            evaluation = self.dataframe._get_value(ID, 'Evaluation')

            # convert
            image = self.fen_to_image(fen)
            label = output_func[output_type](evaluation)

            # store
            x[i,] = image
            y[i,] = label

        return x, y

    def __len__(self):
        'returns the number of batches per epoch'
        return int(np.floor(len(self.IDs) / self.batch_size))

    def __getitem__(self,index):
        '''returns x and y data for a mini batch'''

        # get the indexes and then IDS for the next minibatch
        indexes = self.indexes[index*self.batch_size:(index+1)*self.batch_size]
        temporary_list_IDS = [self.IDs[j] for j in indexes]

        x, y = self.generate_data(batch_IDs = temporary_list_IDS, output_type = self.output_type)

        return x,y

# test_fen = "rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq e3 0 1"
# test_eval = "0"
# data = pd.read_csv('Data/random_evals.csv')
# params = {
#     'IDs' : [0,1,2,3],
#     'data_frame' : data,
#     'batch_size' : 128, 
#     'x_dim' : (8,8,12),
#     'y_dim' : (1),
#     'output_type' : 'normalized'
# }
# x = DataGenerator(**params)

# print(x.normalize_evaluation(test_eval))
# #print(x.fen_to_image(test_fen))